\documentclass[a4paper]{howto}

\setlength\textwidth{6.5in}
\setlength\oddsidemargin{0in}
\setlength\evensidemargin{0in}

%\usepackage[spanish]{babel}
\usepackage[latin1]{inputenc}

\newcommand{\Cimarron}[0]{Cimarrón}

\title{\Cimarron Tutorial}
\author{Marcos Dione and Federico Heinz\\Fundación Vía Libre}
\authoraddress{\email{mdione@vialibre.org.ar}\\\email{fheinz@vialibre.org.ar}}
%\release{0.00}

\begin{document}

\maketitle

\ifhtml
\chapter*{Front Matter}
\fi

\begin{abstract}
 \noindent
 This document is intended as a primer for Python programmers who want
 to get an overview on how to write programs based on \Cimarron.

 \Cimarron is simplified framework designed to help write cross-platform
 database-centric applications, such as accounting systems. It provides
 an abstract widget set that can be presented to the user through the
 native user interface on the system she is running, and is heavily
 based on the Model-View-Controller and the Delegation patterns.

 After reading this document, you should have a general understanding of
 \Cimarron's way of doing things.
\end{abstract}

\tableofcontents

\section{Before you even begin}

Python will have to be able to find \Cimarron{} in order for the
examples in this tutorial to work. Unless \Cimarron{} is installed in a
directory within your \envvar{PYTHONPATH}, you may have to run your
instance of Python with a \envvar{PYTHONPATH} that works. Assuming your
copy of \Cimarron{} is in \file{~/src/cimarron}, the following command
sequence should do the trick:

\begin{verbatim}
~$ cd src/cimarron
~/src/cimarron$ export PYTHONPATH=".:./examples/person:$PYTHONPATH"
~/srcc/imarron$ python
\end{verbatim}

\section{First steps}

Figure~\ref{fig:helloworld} shows the Python code to produce the GUI
equivalent of the ``Hello Word'' program using \Cimarron. Just paste the code
into an instance of Python to get a single window with a single button
in it. The window's title is ``Main Window'', and the button reads ``Hello''.

\begin{figure}[ht]
 \verbatiminput{helloworld.py}
 \caption{\Cimarron{} says hi}\label{fig:helloworld}
\end{figure}

As you can see in the code, we build the window from the outside in,
specifying each new widget's parent as we go. We start declaring
\class{MainWindowController} as a subclass of
\class{WindowController}. As such, every instance will already have a
window associated with it through the \member{win} attribute. The
constructor for \class{MainWindowController} sets the window's title,
and creates a \class{Button} instance, at the same time specifying the
window as its parent, and ``Hello'' as its label.

By convention, you can initialize all the attributes you want on an
instance of a \Cimarron{} object by passing the appropriate keyword
parameters when creating it. For this to work, it is important that
whenever you subclass a \Cimarron{} class, you include the parameter
\var{**kw} in the class' constructor, and that you pass that parameter
along to your superlclass' constructor, as shown in the declaration of
\class{MainWindowController}'s \method{__init__()}. It is worth noting
that the constructor does no checking on the attributes you set this
way, so specifying an undefined attribute will lead to its creation:

\begin{verbatim}
>>> from papo import cimarron
>>> a = Button(foo=42)
>>> a.foo
42
\end{verbatim}

A real \Cimarron{} program would have a class such as
\class{MainWindowController} for each kind of window it uses. The rest
of the program is concerned with creating an instance of 

The program doesn't do anything beyond showing these elements. If the
user interface you are using allows for it, you can use the standard
mechanisms to resize the window, close it, etc. You can even activate
the button, but nothing special will happen. It is interesting to note
that whether you actually see a graphical, textual or web interface
depends on the environment under which you are running the
program. \Cimarron{} provides a set of abstract widgets used to display
and input data. When you run the program, the system decides which user
interface is the most appropriate for your environment, and displays it
accordingly\footnote{At the moment, this is true only in theory:
\Cimarron{} is designed to work that way, but only the GTK2 engine and
available. There is also an experimental and incomplete Qt engine, and
writing new ones is a fairly straightforward task.  Of course, we
wellcome contributions for additional engines, including engines to
enable \Cimarron{} programs to run on proprietary platforms.}.

The rest of the code is the main application. Every \Cimarron{} program
needs an instance of \class{App} (or of a custom subclass of it) to take
care of interaction with the user. After storing the instance of
\class{App} in \var{app}, the program creates an instance of
\class{MainWindowController} and puts it on screen with a call to its
\method{show()} method. It then calls \class{App}'s \method{run()}
method to handle user events. This method exits when the user closes the
last (and in this case only) window.

As an exercise, we suggest that you attempt to modify the code in
Figure~\ref{fig:helloworld} in such a way that
\class{MainWindowController}'s constructor accepts a parameter
\var{title} that allows you to specify the window's title on creation,
with a default value of ``Main Window''. Then modify the main program to
display two (or more) windows with different titles.

\section{Actions}

To get the program to do soemthing more interesting than just displaying
widgets, we can use the \class{Button}'s action. All \Cimarron{}
controls can have an action associated with them. The action is a
callable object that will be invoked by the control whenever it is
triggered (each kind of control defines what it takes to trigger
it). The called function must accept one argument, which will contain
the control that got triggered. This way, the same action can be shared
by different controls.

The code in Figure~\ref{fig:simpleaction} extends the first example to
actually do something when the button is pressed: it prints the message
``Button pressed!'' in the console. Not very useful, but enough for the
purpose of illustration.

\begin{figure}[ht]
 \verbatiminput{simpleaction.py}
 \caption{A simple action}\label{fig:simpleaction}
\end{figure}

Note that although the \method{doSomething()} method ignores the
\var{sender} parameter, it could query the \class{Button} it contains
for information, or otherwise alter it. The code in
Figure~\ref{fig:multiplexedaction} shows how to use a \class{VBox} to
create a stack of two buttons inside the window, and one way to use the
\var{sender} parameter to alter the action according to the control that
got triggered.

\begin{figure}[ht]
 \verbatiminput{multiplexedaction.py}
 \caption{A simple action}\label{fig:multiplexedaction}
\end{figure}

\class{VBox}es and \class{HBox}es are used in \Cimarron{} to lay out
widgets. \class{VBox} stacks the widgets inside it on top of each other
from top to bottom, \class{HBox} makes a horizontal row with them, from
left to right. You can have a \class{VBox} inside a \class{HBox} inside
a \class{VBox}, to as many levels as you want. You could have a
\class{VBox} inside a \class{VBox}, but of course it would be rather
pointless.

\section{Interacting with a model}

\Cimarron{} is meant to help implement applications organized around the
Model-View-Controller pattern. The previous examples have shown
interaction between a controller (\class{MainWindowController}), whose
job is to set up a view (the window and its widgets), complete with the
actions that must occur when something is triggered. The widgets also
know how to interact with a model, to keep track of the values of
particular attributes. To illustrate, we'll use the trivial model shown
in Figure~\ref{fig:simplepersonmodel}, which implements all the methods
that are needed to interact with \Cimarron{} widgets. It is important to
note that attributes that are to be under the control of a \Cimarron{}
widget must be declared as properties.

\begin{figure}[ht]
 \verbatiminput{simpleperson.py}
 \caption{A very simple model that can interact with \Cimarron{}
 widgets}
 \label{fig:simplepersonmodel}
\end{figure}

The code in Figure~\ref{fig:simplepersoneditor} shows how to set up
widgets in such a way that they can reflect the model's status, and
modify it as instructed by the user. As you can see, the bulk of the
code is concerned with creating and packing the widgets. Note that the
\class{Entry} widgets have don't have an associated action. The
controller specifies the model's attribute that will be controlled by
the widget instead. Note that a widget can have both an action and an
attribute associated with it: the action establishes a communications
channel back to the controller, while the attribute acts as a forward
communication with the model.

Once the window is all set up, it is the \class{PersonEditor}
\member{setTarget()} method's responsibility to inform each widget which
concrete instance they are to interact with at any given moment. The
\member{checkValues()} method, invoked every time you press the
``Ckeck'' button, is meant to show that the actual \class{Person}
object's values are being modified through the widgets. Note that this
example defines the \member{target} attribute as a property just for
consistency's sake.

\begin{figure}[ht]
 \verbatiminput{simplepersoneditor.py}
 \caption{A very simple object editor}
 \label{fig:simplepersoneditor}
\end{figure}

\end{document}