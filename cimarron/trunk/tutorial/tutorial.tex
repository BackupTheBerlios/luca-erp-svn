% Copyright 2005 Fundación Via Libre
%
% This file is part of PAPO.
%
% PAPO is free software; you can redistribute it and/or modify it under the
% terms of the GNU General Public License as published by the Free Software
% Foundation; either version 2 of the License, or (at your option) any later
% version.
%
% PAPO is distributed in the hope that it will be useful, but WITHOUT ANY
% WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
% FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
% details.
%
% You should have received a copy of the GNU General Public License along with
% PAPO; if not, write to the Free Software Foundation, Inc., 59 Temple Place,
% Suite 330, Boston, MA 02111-1307 USA
% 
\documentclass[a4paper]{howto}

\setlength\textwidth{6.5in}
\setlength\oddsidemargin{0in}
\setlength\evensidemargin{0in}

%\usepackage[spanish]{babel}
\usepackage[latin1]{inputenc}

\newcommand{\Cimarron}[0]{Cimarrón}

\title{\Cimarron Tutorial}
\author{Marcos Dione and Federico Heinz\\Fundación Vía Libre}
\authoraddress{\email{mdione@vialibre.org.ar}\\\email{fheinz@vialibre.org.ar}}
%\release{0.00}

\begin{document}

\maketitle

\ifhtml
\chapter*{Front Matter}
\fi

\begin{abstract}
 \noindent
 This document is intended as a primer for Python programmers who want
 to get an overview on how to write programs based on \Cimarron.

 \Cimarron\ is a simplified framework designed to help write
 cross-platform database-centric applications, such as accounting
 systems. It provides an abstract widget set that can be presented to
 the user through the native user interface on the system she is
 running, and is heavily based on the Model-View-Controller and the
 Delegation patterns.

 After reading this document, you should have a general understanding of
 \Cimarron's way of doing things.
\end{abstract}

\tableofcontents

\section{Before you even begin}

Python will have to be able to find \Cimarron{} in order for the
examples in this tutorial to work. Unless \Cimarron{} is installed in
a directory within your \envvar{PYTHONPATH}, you may have to run your
instance of Python with a \envvar{PYTHONPATH} that works. Assuming
your copy of \Cimarron{} is in \file{\textasciitilde/src/cimarron},
the following command sequence should do the trick:

\begin{verbatim}
~$ cd src/cimarron
~/src/cimarron$ export PYTHONPATH=".:./examples/person:$PYTHONPATH"
~/src/cimarron$ python
\end{verbatim}

\section{First steps}

Here is the Python code to produce the GUI equivalent of the ``Hello
Word'' program using \Cimarron. Just paste the code into an instance of
Python to get a single window with a single button in it. The window's
title is ``Main Window'', and the button reads ``Hello''.

\verbatiminput{helloworld.py}

As you can see in the code, we build the window from the outside in,
specifying each new widget's parent as we go. We start declaring
\class{MainWindowController} as a subclass of
\class{WindowController}. As such, every instance will already have a
window associated with it through the \member{win} attribute. The
constructor for \class{MainWindowController} sets the window's title,
and creates a \class{Button} instance, at the same time specifying the
window as its parent, and ``Hello'' as its label.

By convention, you can initialize all the attributes you want on an
instance of a \Cimarron{} object by passing the appropriate keyword
parameters when creating it. For this to work, it is important that
whenever you subclass a \Cimarron{} class, you include the parameter
\var{**kw} in the class' constructor, and that you pass that parameter
along to your superlclass' constructor, as shown in the declaration of
\class{MainWindowController}'s \method{__init__()}. It is worth noting
that the constructor does no checking on the attributes you set this
way, so specifying an undefined attribute will lead to its creation:

\begin{verbatim}
>>> from fvl import cimarron
>>> a = Button(foo=42)
>>> a.foo
42
\end{verbatim}

The program doesn't do anything beyond showing these elements. If the
user interface you are using allows for it, you can use the standard
mechanisms to resize the window, close it, etc. You can even activate
the button, but nothing special will happen. It is interesting to note
that whether you actually see a graphical, textual or web interface
depends on the environment under which you are running the
program. \Cimarron{} provides a set of abstract widgets used to display
and input data. When you run the program, the system decides which user
interface is the most appropriate for your environment, and displays it
accordingly\footnote{At the moment, this is true only in theory:
\Cimarron{} is designed to work that way, but only the GTK2 engine and
available. There is also an experimental and incomplete Qt engine, and
writing new ones is a fairly straightforward task.  Of course, we
wellcome contributions for additional engines, including engines to
enable \Cimarron{} programs to run on proprietary platforms.}.

The rest of the code is the main application. Every \Cimarron{} program
needs an instance of \class{App} (or of a custom subclass of it) to take
care of interaction with the user. After storing the instance of
\class{App} in \var{app}, the program creates an instance of
\class{MainWindowController} and puts it on screen with a call to its
\method{show()} method. It then calls \class{App}'s \method{run()}
method to handle user events. This method exits when the user closes the
last (and in this case only) window.

As an exercise, we suggest that you attempt to modify the code above in
such a way that \class{MainWindowController}'s constructor accepts a
parameter \var{title} that allows you to specify the window's title on
creation, with a default value of ``Main Window''. Then modify the main
program to display two (or more) windows with different titles.

\section{Actions}

To get the program to do soemthing more interesting than just displaying
widgets, we can use the \class{Button}'s action. All \Cimarron{}
controls can have an action associated with them. The action is a
callable object that will be invoked by the control whenever it is
triggered (each kind of control defines what it takes to trigger
it). The called function must accept one argument, which will contain
the control that got triggered. This way, the same action can be shared
by different controls.

The following code extends the first example to actually do something
when the button is pressed: it prints the message ``Button pressed!'' in
the console. Not very useful, but enough for the purpose of
illustration.

\verbatiminput{simpleaction.py}

Note that although the \method{doSomething()} method ignores the
\var{sender} parameter, it could query the \class{Button} it contains
for information, or otherwise alter it. For example, this program shows
how to use a \class{VBox} to create a stack of two buttons inside the
window, and one way to use the \var{sender} parameter to influence the
action's outcome according to data obtained from the triggered control.

\verbatiminput{multiplexedaction.py}

\class{VBox}es and \class{HBox}es are used in \Cimarron{} to lay out
widgets. \class{VBox} stacks the widgets inside it on top of each other
from top to bottom, \class{HBox} makes a horizontal row with them, from
left to right. You can have a \class{VBox} inside a \class{HBox} inside
a \class{VBox}, to as many levels as you want. You could have a
\class{VBox} inside a \class{VBox}, but of course it would be rather
pointless.

\section{Interacting with a model}

\Cimarron{} is meant to help implement applications organized around the
Model-View-Controller pattern. The previous examples have shown
interaction between a controller (\class{MainWindowController}), whose
job is to set up a view (the window and its widgets), complete with the
actions that must occur when something is triggered. The widgets also
know how to interact with a model, to keep track of the values of
particular attributes. To illustrate, we'll use the following trivial
model, which implements all the methods that are needed to interact with
\Cimarron{} widgets. It is important to note that attributes that are to
be under the control of a \Cimarron{} widget must be declared as
properties.

\verbatiminput{simpleperson.py}

Given this model, here's how a program can set up widgets in such a way
that they can reflect the model's status, and modify it as instructed by
the user.

\verbatiminput{simplepersoneditor.py}

As you can see, the bulk of the code is concerned with creating and
packing the widgets. Note that the \class{Entry} widgets have don't have
an associated action. The controller specifies the model's attribute
that will be controlled by the widget instead. Note that a widget can
have both an action and an attribute associated with it: the action
establishes a communications channel back to the controller, while the
attribute acts as a forward communication with the model.

Once the window is all set up, it is \class{PersonEditor}'s
\member{setTarget()} method's responsibility to inform each widget which
concrete instance they are to interact with at any given moment. The
\member{checkValues()} method, invoked every time you press the
``Ckeck'' button, is meant to show that the actual \class{Person}
object's values are being modified through the widgets. Note that this
example defines the \member{target} attribute as a property just for
consistency's sake.

\end{document}
